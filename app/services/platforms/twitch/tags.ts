import { Observable, EMPTY } from 'rxjs';
import { ajax } from 'rxjs/ajax';
import { concatMap, expand, filter, map, toArray } from 'rxjs/operators';
import { sortBy1 } from 'fp-ts/lib/Array';
import { compose } from 'fp-ts/lib/function';
import { fromNullable } from 'fp-ts/lib/Option';
import { contramap, ordString } from 'fp-ts/lib/Ord';
import { TwitchPagination } from './pagination';

/**
 * A tag on Twitch that could be assigned to a Stream.
 */
export type TwitchTag = {
  tag_id: string;
  /**
   * `true` if the tag is autogenerated.
   */
  is_auto: boolean;
  localization_names: {
    /**
     * Keys are locale names, in underscore (e.g. en-us). Values are the translations.
     */
    [x: string]: string;
  };
  localization_descriptions: {
    [x: string]: string;
  };
};

/**
 * TwitchTag with a label in the user's locale or en-US as fallback
 */
export type TwitchTagWithLabel = TwitchTag & { name: string };

/**
 * Response coming from Twitch from the Tags endpoint.
 */
type TwitchTagsResponse = {
  data: TwitchTag[];
  pagination: TwitchPagination;
};

export interface TwitchRequestHeaders {
  Accept: 'application/vnd.twitchtv.v5+json';
  Authorization?: string;
  'Client-Id': string;
  'Content-Type': 'application/json';
}

/**
 * Intermediate representation of a Twitch tag response so
 * we can request subsequent pages of tags.
 */
interface PaginatedResponse {
  items: TwitchTag[];
  cursor: string;
}

const requestTags = (
  headers: TwitchRequestHeaders,
  cursor: string,
): Observable<PaginatedResponse> =>
  ajax
    .getJSON<TwitchTagsResponse>(
      `https://api.twitch.tv/helix/tags/streams?first=100&after=${cursor}`,
      headers,
    )
    .pipe(
      map(response => ({
        cursor: response.pagination.cursor,
        items: response.data,
      })),
    );

/**
 * Fetch all available tags that Twitch provides that are not
 * automatically generated. This will use the provided pagination
 * to request the whole dataset of tags.
 *
 * @param headers Headers including OAuth Token and App ID
 */
export const getAllTags = (headers: TwitchRequestHeaders): Promise<TwitchTag[]> =>
  requestTags(headers, '')
    .pipe(
      expand(({ cursor }) => (cursor ? requestTags(headers, cursor) : EMPTY)),
      concatMap(({ items }) => items),
      filter(tag => !tag.is_auto),
      toArray(),
    )
    .toPromise();

export const getStreamTags = (
  broadcasterId: string,
  headers: TwitchRequestHeaders,
): Promise<TwitchTag[]> =>
  ajax
    .getJSON<TwitchTagsResponse>(
      `https://api.twitch.tv/helix/streams/tags?broadcaster_id=${broadcasterId}`,
      headers,
    )
    .pipe(
      // prettier-ignore
      concatMap(({ data }) => data),
      filter(tag => !tag.is_auto),
      toArray(),
    )
    .toPromise();

const getLabelFor = (tag: TwitchTag, locale: string): string =>
  tag.localization_names[locale.toLowerCase()] || tag.localization_names['en-us'];

const assignLabels = (locale: string) => (tags: TwitchTag[]): TwitchTagWithLabel[] =>
  tags.map(tag => ({
    ...tag,
    name: getLabelFor(tag, locale),
  }));

const byName = contramap((tag: TwitchTagWithLabel) => tag.name, ordString);
const sortByName = sortBy1(byName, []);

export const prepareOptions = (
  locale: string,
  tags: TwitchTag[] | undefined,
): TwitchTagWithLabel[] =>
  fromNullable(tags)
    .map(
      compose(
        sortByName,
        assignLabels(locale),
      ),
    )
    .getOrElse([]);

export const updateTags = (headers: TwitchRequestHeaders) => (tags: TwitchTagWithLabel[]) => (
  streamId: string,
) =>
  ajax
    .put(
      `https://api.twitch.tv/helix/streams/tags?broadcaster_id=${streamId}`,
      JSON.stringify({ tag_ids: tags.map(tag => tag.tag_id) }),
      headers,
    )
    .toPromise();
